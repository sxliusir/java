# 一、代码块

#### 概念

使用{}括起来的一段代码叫做代码块。

#### 分类

普通代码块：定义在方法中，使用{}括起来的代码叫做普通代码块。 
 
构造代码块：定义在类中的使用{}括起来的代码叫做构造代码块。  

注意：每次代码运行的时候回将构造代码块中的代码添加到构造方法的前面，构造代码块中的代码会添加到每一个构造方法中，当使用this(参数)的时候不会添加。
  
静态代码块：使用static{}括起来的代码叫做静态代码块，在程序载入的时候优先执行。数据库连接等其他提前需要准备好的代码会放在static代码块。  

同步代码块：在多线程的时候回使用，用来给共享空间进行加锁操作。

#### 执行顺序

静态代码块--》构造代码块（创建对象的时候才会用到）--》普通代码块

# 二、package
#### 概念

包，对应到文件系统就是多级目录。
  
为了解决两个问题：
  
1、文件同名问题；  

2、为了方便管理类，将具体处理功能的代码放到同一个目录下；

#### 使用

一般定义package会放置在java文件的第一行。 
 
package 域名的倒写，如 package com.sxliusir.*

#### 常用的包

lang：不需要手动导入，自动加载  

util:工具包  

net:网络包  

io:输入输出流包

# 三、this

this:表示当前对象的指针,指向当前对象，表示当前对象的引用

#### 用处

1、构造方法，当构造方法中的参数名称跟类的成员变量名称一样的时候，可以使用this代表当前对象  

注意：
  
有了this之后，可以将构造方法的参数跟成员变量保持一致  

当构造方法中需要调用其他的构造方法时，可以使用this(name)调用其他构造方法，但是必须位于方法体的第一行  

2、普通方法中：  

当多个普通方法之间需要调用的时候，可以使用this来进行调用，指的是当前对象的其他方法  

3、成员变量的使用：  

当方法中的参数名称跟成员变量保持一致的时候，使用this.变量名称 表示的是对象的值，而使用变量名称表示形参列表中的值

# 四、构造方法

#### 注意

1、创建完类之后，如果没有手动调用构造方法，会有一个默认的无参的构造方法供调用  

2、当用户自定义了构造方法之后，默认的无参构造方法就不能够使用了，必须要手动定义无参构造方法
  
3、同一个类中可以包含多个同名的构造方法

# 五、重载

在一个类中可以包含多个重名的方法，但是注意方法的参数列表不能相同  

三个方面的不同：参数的个数不同、参数的类型不同、参数的顺序不同 
 
注意：  

一般构造方法都会进行重载（一个类中可能包含多个属性值，当只需要给部分属性初始化的时候需要调用不同的构造方法）

# 六、static

修饰成员变量的时候，表示静态成员变量或者叫类变量  

普通变量在使用的时候，必须要通过对象名进行调用  

类变量或者静态变量可以使用对象名调用也可以使用类名进行调用 
 
修饰方法的时候，表示静态方法或者叫类方法  

普通方法在使用的时候，必须要通过对象名进行调用 
 
类方法或者静态方法可以使用类名，也可以使用对象名  

注意：
  
1、静态变量，在创建对象之前被初始化，或者说在类被载入之前进行初始化  

2、静态变量被所有的对象共享，属于公共变量，对象和类都可以直接调用，但是推荐使用类来调用  

3、成员变量放在堆中，而静态变量放在方法去中静态区 
 
4、静态变量不能定义在静态方法中  

5、静态方法可以在非静态方法中进行调用  

6、静态方法中不能直接调用非静态方法  

7、静态方法中不允许出现this调用  

8、一般工具类中的方法定义为static  

# 七、封装

概念：  

将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法（setName，getName）来实现对隐藏信息的操作和访问  

封装解决什么问题：  

如果任何一个处理类都可以直接对其属性（age）进行赋值操作，那么当值不准确的时候，可以回产生额外的结果，如何在赋值的同时添加一些逻辑判断呢？封装可以解决此问题。  

作用：  

使用封装可以保证数据的规范，不符合规范的数据将无法进行操作  

好处：  

1、隐藏类的内部实现细节；  

2、只能通过提供的方法（setName，getName）进行访问，其他方法无法访问；
  
3、可以根据需求添加复杂的逻辑判断语句；  

4、方便修改实现；  

面向对象的封装（狭义）可以用一句话概述： 
为了保证数据安全和规范，将类中的属性设置为私有属性，提供共有的外部方法供程序进行调用，可以实现丰富的细节操作  

广义的封装：可以将完成特定功能的代码块封装成一个方法，供不同的程序进行调用。  

# 八、高内聚，低耦合

高内聚：就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用。

# 九、继承

表示父类跟子类之间的关系，当两个类或者多个类具备相同的属性和方法的时候，可以提取出来，变成父类，子类可以继承。子类跟父类是is-a的关系。  

使用：  

1、使用继承的时候需要使用extend关键字  

2、使用继承关系之后，父类中的属性和方法都可以在子类中进行使用(非私有属性和非私有方法) 
 
3、java中是单继承关系(如果包含多个父类，同时父类中包含重名方法，无法决定改调用谁)  

super:是 直接父类 对象的引用  

用途：  

1、可以在子类中调用父类中被子类覆盖的方法  super.父类方法名称  

2、当super在普通方法中使用的话，可以任意位置编写  

3、当super在构造方法中使用的话，会调用父类的构造方法，一定要将super放在第一行
  
4、在构造方法中super关键字和this关键字不能同时出现  

5、父类中私有的属性和方法都不能被调用，包括构造方法  

6、子类的构造方法中都会默认使用super关键字调用父类的无参构造方法,因此在定义类的时候，无论自己是否自定义了其他构造方法，最好将无参构造方法写上  

7、如果构造方法中显式的指定了super的构造方法，那么无参的构造方法就不会被调用  

总结：  

1、在创建子类对象的时候一定会优先创建父类对象  

2、所有的java类都具备同一个老祖宗类，称之为Object，是所有类的根类  

# 十、重写

必须要存在继承关系，当父类中的方法无法满足子类需求的时候可以选择使用重写的方式  

注意：
  
1、重写表示的是子类覆盖父类的方法，当覆盖之后，调用同样的方法的时候会优先调用子类  

2、重写的方法名称，返回值类型，参数列表必须跟父类一直  

3、子类重写的方法不允许比父类的方法具备更小的访问权限  

父类      public     子类  public  

父类      protected     子类  public protected  

父类      protected     子类  public protected  default  

父类的静态方法子类可以进行调用，但是子类不可以重写  

# 十一、多态
对应同一个指令（调用同一个名称的方法），不同的对象给予不同的反应（不同的方法实现）  

规范(多态实现的前提)：  

1、必须要有继承关系  

2、子类方法必须重写父类的方法  

3、父类引用指向子类对象  

多态的目的：  

为了提高代码的扩展性和维护性  

方便代码逻辑的编写  

多态的两种表现形式：  

1、父类作为方法的参数  

2、父类作为方法的返回值类型  

引用类型的转换跟基本数据类型的转换类似：
  
1、当父类需要转成子类的时候，要进行强制转换，但是在强制转换之前一定要先判断父类引用指向的子类对象到底是谁,如果无法确定，在运行过程中可能出错。  

2、当子类需要向父类转换的时候，直接自动转换，不需要进行任何的判断。  

# 十二、接口

java中的继承关系是单继承，如果拥有多个父类的时候，可以考虑使用接口进行实现

java中的接口具备广泛的使用：

用法：使用interface来修饰

接口中可以包含多个方法，且方法跟抽象类中的抽象方法一致，可以不写实现，子类在实现的时候必须要实现代码逻辑

子类实现接口使用implements关键字

特征：

	1、接口中的所有方法都是抽象方法，不能包含方法的实现

	2、接口中的所有方法的访问修饰权限都是public，不写并不是默认访问权限，而是public

	3、接口不能被实例化

	4、接口的子类必须要实现接口中的所有方法，跟抽象类有所不同，抽象类中的抽象方法必须要被子类实现

	5、子类可以拥有实现多个接口

	6、接口中的变量都是静态常量,如果变量没有使用static关键字修饰，它也表示静态常量,不用final关键字修饰，也是常量

	7、接口中的方法和常量无论是否添加public修饰，默认的权限有且仅有一个，就是public

接口的使用：

接口代表一种能力，接口中可以定义N多个方法，子类在进行实现的时候，必须要实现这些方法，将这些方法进行实现，就意味着具体了方法的能力，关心实现类有何能力，而不关心实现细节

抽象类和接口的区别：

	1、抽象类中的方法可以有抽象方法，也可以有普通方法，但是接口中只能包含抽象方法

	2、抽象类需要使用abstract关键字来修饰，而接受使用interface关键字来修饰

	3、子类使用extends关键字来继承抽象类，使用implements来实现接口

	4、子类继承抽象类的时候必须要实现所有的抽象方法，普通方法可以不重写，而接口中的所有方法必须实现

	5、抽象类中可以定义成员变量，而接口中只能定义静态常量

	6、抽象类在子类实现的时候是单继承，而接口时多继承

	7、抽象类和接口都不能实例化，但是抽象类中可以有构造方法，而接口中不能有构造方法

	8、抽象类中可以实现接口，并且不实现接口中方法，而接口只能继承接口，不能实现接口

注意：

在实际的项目开发过程中，如果可以使用接口，尽量使用接口，将单继承的父类留在最关键的地方